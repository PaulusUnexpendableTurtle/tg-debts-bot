function BotFactory(BaseBot) {
    return function Bot(token, url, port) {
        var bot = new BaseBot(token, { webHook : { port : port } });
        bot.setWebHook(`${url}/bot${token}`);

        var dataBase;
        bot.setDataBase = client => { dataBase = client; };

        var name;
        bot.setName = botName => { name = botName; };

        bot.onText(/\/start/, msg => {
            dataBase.setState(msg.chat.id, states.MAIN)
                .then(() => {
                    return bot.sendMessage(msg.chat.id, startText());
                })
                .catch(error => {
                    console.log(error);
                });
        });

        const startText = () => {
            return `–ü—Ä–∏–≤–µ—Ç! üëã\n`
                 + `–Ø ‚Äî –∑–∞–ø–∏—Å–Ω–∞—è –∫–Ω–∏–∂–∫–∞ –¥–æ–ª–≥–æ–≤.\n\n`
                 + `üí∞ –ß—Ç–æ–±—ã –ø–æ–ø—Ä–æ—Å–∏—Ç—å –≤ –¥–æ–ª–≥, –Ω–∞–ø–∏—à–∏ —Å—É–º–º—É.\n\n`
                 + `üóÑ –ß—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ –¥–æ–ª–≥–∏, –Ω–∞–ø–∏—à–∏ /stats.\n\n`
                 + `üëã –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–∑–¥–æ—Ä–æ–≤–∞—Ç—å—Å—è –µ—â—ë —Ä–∞–∑, –Ω–∞–ø–∏—à–∏ /start.\n\n`
                 + `‚ùì –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ, –Ω–∞–ø–∏—à–∏ /help.`;
        };

        bot.onText(/\/help/, msg => {
            dataBase.setState(msg.chat.id, states.MAIN)
                .then(() => {
                    return bot.sendMessage(msg.chat.id, helpText());
                })
                .catch(error => {
                    console.log(error);
                });
        });

        const helpText = () => {
            return `–ö–æ–º–∞–Ω–¥—ã ([—Ç–µ–∫—Å—Ç] ‚Äî –ø–æ –≤–∫—É—Å—É):\n\n`
                 + ` N [—Ç–µ–∫—Å—Ç] ‚Äî –ø–æ–ø—Ä–æ—Å–∏—Ç—å N üí∞.\n`
                 + `-N [—Ç–µ–∫—Å—Ç] ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å N üí∞.\n`
                 + `/stats ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ –¥–æ–ª–≥–∏.\n`
                 + `/share ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —ç—Ç–∏–º ü§ñ.\n`
                 + `/start ‚Äî –∫—Ä–∞—Ç–∫–∞—è —Å–ø—Ä–∞–≤–∫–∞.\n`
                 + `/help ‚Äî —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\n`
                 + `–ò–Ω–ª–∞–π–Ω (@${name} + –∫–æ–º–∞–Ω–¥–∞):\n\n`
                 + `–ø—É—Å—Ç–æ ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —ç—Ç–∏–º ü§ñ.\n`
                 + ` N [—Ç–µ–∫—Å—Ç] ‚Äî –ø–æ–ø—Ä–æ—Å–∏—Ç—å üí∞.\n`
                 + `-N [—Ç–µ–∫—Å—Ç] ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å üí∞.`;
        };

        bot.onText(/\/share/, msg => {
            dataBase.setState(msg.chat.id, states.MAIN)
                .then(() => {
                    return bot.sendMessage(
                        msg.chat.id,
                        shareText(),
                        shareKeyboard
                    );
                })
                .catch(error => {
                    console.log(error);
                });
        });

        const shareText = () => {
            return `–ü—Ä–∏–≤–µ—Ç! üëã\n`
                 + `–Ø ‚Äî –î–æ–ª–≥–µ—Ä (@${name}), –∑–∞–ø–∏—Å–Ω–∞—è –∫–Ω–∏–∂–∫–∞ –¥–æ–ª–≥–æ–≤.\n`
                 + `–ï—â—ë —É–≤–∏–¥–∏–º—Å—è?`;
        }

        bot.onText(/\/stats/, msg => {
            dataBase.setState(msg.chat.id, states.MAIN)
                .then(() => {
                    return dataBase.getStats(msg.from.username);
                })
                .then(table => {
                    return bot.sendMessage(
                        msg.chat.id,
                        formatTable(table),
                        { reply_markup: statsKeyboard }
                    );
                })
                .catch(error => {
                    console.log(error);
                });
        });

        bot.onText(debtRegexp, (msg, match) => {
            dataBase.setState(msg.chat.id, states.MAIN)
                .then(() => {
                    if (match[1].length < DIGITS_LIMIT)
                        return sendDebtTemplate(msg, match);
                    else
                        return bot.sendMessage(
                            msg.chat.id,
                            `‚ùå –†–∞–∑–º–µ—Ä –¥–æ–ª–≥–∞ –Ω–µ—Ä–µ–∞–ª—å–Ω–æ –±–æ–ª—å—à–æ–π ‚ùå`
                        );
                })
                .catch(error => {
                    console.log(error);
                });
        });

        const sendDebtTemplate = (msg, match) => {
            return bot.sendMessage(
                    msg.chat.id,
                       userText(match[2], match[1])
                    || debtText(Number(match[1]), msg.from.username),
                    {
                        reply_markup: JSON.stringify({
                            inline_keyboard: [[ {
                                text: offerButton(match[1][0]),
                                switch_inline_query: match[1]
                                                   + (match[2] || '')
                            } ]]
                        })
                    })
                .then(() => {
                    console.log('amount: ' + match[1])
                });
        };

        bot.on('inline_query', query => {
            let answer;

            if (debtRegexp.test(query.query)) {
                let match = query.query.match(debtRegexp);

                if (match[1].length >= DIGITS_LIMIT) {
                    return bot.answerInlineQuery(
                        query.id,
                        []
                    );
                }

                let offer = {
                    from: query.from.username,
                    amount: Number(match[1])
                };

                return dataBase.saveOfferGetID(offer)
                    .then(id => {
                        answer = {
                            type: 'article',
                            id: articleID(),
                            title: debtTitle(offer.amount),
                            input_message_content: {
                                message_text: userText(match[2], offer.amount)
                                           || debtText(offer.amount, offer.from)
                            },
                            reply_markup: {
                                inline_keyboard: [[
                                    {
                                        text: '–û–∫ üåù',
                                        callback_data: `${id} 1`
                                    },
                                    {
                                        text: '–ù–µ üåö',
                                        callback_data: `${id} 0`
                                    }
                                ]]
                            }
                        };

                        return bot.answerInlineQuery(
                            query.id,
                            [answer],
                            { cache_time: 0 }
                        );
                    })
                    .catch(error => {
                        console.log(error);
                    });
            } else if (query.query == 'share' || query.query == '') {
                answer = {
                    type: 'article',
                    id: articleID(),
                    title: '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è ü§ñ',
                    input_message_content: {
                        message_text: shareText()
                    }
                };

                return bot.answerInlineQuery(
                        query.id,
                        [answer],
                        { cache_time: 0 }
                    )
                    .catch(error => {
                        console.log(error);
                    });
            } else {
                return bot.answerInlineQuery(
                    query.id,
                    []
                );
            }
        });

        let article_id = 0;
        const articleID = () => article_id++;

        bot.on('callback_query', query => {
            if (query.data == 'update') {
                dataBase.getStats(query.from.username)
                    .then(table => {
                        return bot.editMessageText(
                            formatTable(table)
                            + '\n\n–û–±–Ω–æ–≤–ª–µ–Ω–æ '
                            + new Date()
                                .toLocaleString(query.from.language_code),
                            {
                                chat_id: query.message.chat.id,
                                message_id: query.message.message_id,
                                reply_markup: statsKeyboard
                            });
                    })
                    .then(() => {
                        return bot.answerCallbackQuery(
                            query.id,
                            { text: '–û–±–Ω–æ–≤–ª–µ–Ω–æ.' }
                        );
                    })
                    .catch(error => {
                        console.log(error);
                    });
            } else {
                let answer = parse(query.data);
                let by = query.from.username;

                dataBase.getOffer(answer.offer_id)
                    .then(offer => {
                        if (by == offer.from) {
                            if (answer.accept) {
                                return bot.answerCallbackQuery(
                                    query.id,
                                    { text: `–ù–µ–ª—å–∑—è –¥–æ–ª–∂–∞—Ç—å —Å–µ–±–µ` }
                                );
                            } else {
                                return dataBase.deleteOffer(answer.offer_id)
                                    .then(() => {
                                        return bot.editMessageText(
                                            `–û—Ç–º–µ–Ω–µ–Ω–æ @${by}`,
                                            { inline_message_id:
                                                query.inline_message_id }
                                        );
                                    });
                            }
                        } else {
                            return dataBase.deleteOffer(answer.offer_id)
                                .then(() => {
                                    return bot.editMessageText(
                                        closedDealMsg(
                                            offer.from,
                                            offer.amount,
                                            by,
                                            answer.accept
                                        ),
                                        { inline_message_id:
                                            query.inline_message_id }
                                    );
                                });
                                .then(() => {
                                    if (answer.accept)
                                        return dataBase.saveDebt(
                                            offer.from,
                                            offer.amount,
                                            by
                                        );
                                    else
                                        return pass();
                                });
                        }
                    })
                    .catch(error => {
                        console.log(error);
                    });
            }
        });

        return bot;
    };
};

const shareKeyboard = {
    reply_markup: JSON.stringify({
        inline_keyboard: [[ {
            text: '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è ü§ñ',
            switch_inline_query: ''
        } ]]
    })
};

const formatTable = table =>
    table.length
    ?   table.reduce((res, line) => {
            return res
                 + `\n@${line.to_name}: ${line.amount}`;
        }, '–î–æ–ª–≥–∏:\n')
    :   '–ù–µ—Ç –¥–æ–ª–≥–æ–≤';

const statsKeyboard = JSON.stringify({
    inline_keyboard: [[ {
        text: '–û–±–Ω–æ–≤–∏—Ç—å üîÑ',
        callback_data: 'update'
    } ]]
});

const debtRegexp = /(-?\d+)(.+)?/;

const DIGITS_LIMIT = 9;

const userText = (text, amount) =>
    (text && (text.length > 1))
    ?   (text.substr(1) + `\n\n‚ÄºÔ∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${amount} ‚ÄºÔ∏è`)
    :   null;

const debtText = (amount, to) =>
    `–Ø ${amount > 0 ? '—Ö–æ—á—É' : '–¥–∞—é'} ${Math.abs(amount)} (${to})`;

const offerButton = (minus) =>
    (minus == '-' ? '–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å' : '–ü–æ–ø—Ä–æ—Å–∏—Ç—å') + ' üí∞';

const debtTitle = amount =>
    `${amount > 0 ? `–ü–æ–ø—Ä–æ—Å–∏—Ç—å` : `–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å`} ${Math.abs(amount)}`;

const parse = src => {
    let spl = src.split(' ');
    console.log('split result:', spl);
    return {
        offer_id: Number(spl[0]),
        accept: spl[1] == '1'
    };
};

const closedDealMsg = (from, amount, to, accept) => {
    let arg1 = amount > 0 ? `–¥–æ–ª–≥–∞ (–∫–æ–ª-–≤–æ: ${amount})` : -amount;
    let arg2 = accept ? `–ø—Ä–∏–Ω—è—Ç–æ` : `–æ—Ç–≤–µ—Ä–≥–Ω—É—Ç–æ`;
    return `–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ ${arg1} –±—ã–ª–æ ${arg2} @${to}. (${from})`
};

const states = {
    MAIN: 0,
    DEBT_AMOUNT: 1
};

const pass = (...args) => new Promise(next => next(...args));

if (module) module.exports = BotFactory;
