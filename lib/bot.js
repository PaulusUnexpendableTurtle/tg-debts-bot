const BaseBot = require('node-telegram-bot-api');

function Bot(token, url, port) {
    var bot = new BaseBot(token, { webHook : { port : port } });

    var name;
    this.setName = function(botName) {
        name = botName;
    };

    var dataBase;
    this.setDataBase = function(client) {
        dataBase = client;
    };

    var cipher;
    this.setCipher = function(dataCipher) {
        cipher = dataCipher;
    };

    this.start = function() {
        bot.setWebHook(`${url}/bot${token}`);
    };

    bot.onText(/\/start/, msg => {
        dataBase.setState(msg.chat.id, states.MAIN)
            .then(() => {
                return bot.sendMessage(msg.chat.id, startText());
            })
            .catch(logger);
    });

    function startText() {
        return `–ü—Ä–∏–≤–µ—Ç! üëã\n`
             + `–Ø ‚Äî –∑–∞–ø–∏—Å–Ω–∞—è –∫–Ω–∏–∂–∫–∞ –¥–æ–ª–≥–æ–≤.\n\n`
             + `üí∞ –ß—Ç–æ–±—ã –ø–æ–ø—Ä–æ—Å–∏—Ç—å –≤ –¥–æ–ª–≥, –Ω–∞–ø–∏—à–∏ —Å—É–º–º—É.\n\n`
             + `üóÑ –ß—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ –¥–æ–ª–≥–∏, –Ω–∞–ø–∏—à–∏ /stats.\n\n`
             + `üëã –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–∑–¥–æ—Ä–æ–≤–∞—Ç—å—Å—è –µ—â—ë —Ä–∞–∑, –Ω–∞–ø–∏—à–∏ /start.\n\n`
             + `‚ùì –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ, –Ω–∞–ø–∏—à–∏ /help.`;
    };

    bot.onText(/\/help/, msg => {
        dataBase.setState(msg.chat.id, states.MAIN)
            .then(() => {
                return bot.sendMessage(msg.chat.id, helpText());
            })
            .catch(logger);
    });

    function helpText() {
        return `–ö–æ–º–∞–Ω–¥—ã ([—Ç–µ–∫—Å—Ç] ‚Äî –ø–æ –≤–∫—É—Å—É):\n\n`
             + ` N [—Ç–µ–∫—Å—Ç] ‚Äî –ø–æ–ø—Ä–æ—Å–∏—Ç—å N üí∞.\n`
             + `-N [—Ç–µ–∫—Å—Ç] ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å N üí∞.\n`
             + `/stats ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ –¥–æ–ª–≥–∏.\n`
             + `/share ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —ç—Ç–∏–º ü§ñ.\n`
             + `/start ‚Äî –∫—Ä–∞—Ç–∫–∞—è —Å–ø—Ä–∞–≤–∫–∞.\n`
             + `/help ‚Äî —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\n`
             + `–ò–Ω–ª–∞–π–Ω (@${name} + –∫–æ–º–∞–Ω–¥–∞):\n\n`
             + `–ø—É—Å—Ç–æ ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —ç—Ç–∏–º ü§ñ.\n`
             + ` N [—Ç–µ–∫—Å—Ç] ‚Äî –ø–æ–ø—Ä–æ—Å–∏—Ç—å üí∞.\n`
             + `-N [—Ç–µ–∫—Å—Ç] ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å üí∞.`;
    };

    bot.onText(/\/share/, msg => {
        dataBase.setState(msg.chat.id, states.MAIN)
            .then(() => {
                return bot.sendMessage(
                    msg.chat.id,
                    shareText(),
                    shareKeyboard
                );
            })
            .catch(logger);
    });

    function shareText() {
        return `–ü—Ä–∏–≤–µ—Ç! üëã\n`
             + `–Ø ‚Äî –î–æ–ª–≥–µ—Ä (@${name}), –∑–∞–ø–∏—Å–Ω–∞—è –∫–Ω–∏–∂–∫–∞ –¥–æ–ª–≥–æ–≤.\n`
             + `–ï—â—ë —É–≤–∏–¥–∏–º—Å—è?`;
    }

    bot.onText(/\/stats/, msg => {
        dataBase.setState(msg.chat.id, states.MAIN)
            .then(() => {
                return dataBase.getStats(msg.from.username);
            })
            .then(table => {
                return bot.sendMessage(
                    msg.chat.id,
                    formatTable(table),
                    { reply_markup : statsKeyboard }
                );
            })
            .catch(logger);
    });

    bot.onText(debtRegexp, (msg, match) => {
        dataBase.setState(msg.chat.id, states.MAIN)
            .then(() => {
                if (match[1].length < DIGITS_LIMIT)
                    return sendDebtTemplate(msg, match);
                else
                    return bot.sendMessage(
                        msg.chat.id,
                        `‚ùå –†–∞–∑–º–µ—Ä –¥–æ–ª–≥–∞ –Ω–µ—Ä–µ–∞–ª—å–Ω–æ –±–æ–ª—å—à–æ–π ‚ùå`
                    );
            })
            .catch(logger);
    });

    function sendDebtTemplate(msg, match) {
        return bot.sendMessage(
                msg.chat.id,
                   userText(match[2], match[1])
                || debtText(Number(match[1]), msg.from.username),
                {
                    reply_markup : JSON.stringify({
                        inline_keyboard : [[ {
                            text : offerButton(match[1][0]),
                            switch_inline_query : match[1]
                                               + (match[2] || '')
                        } ]]
                    })
                })
            .then(() => {
                console.log('\namount :', match[1]);
            });
    };

    bot.on('inline_query', query => {
        let answer;

        if (debtRegexp.test(query.query)) {
            let match = query.query.match(debtRegexp);

            if (match[1].length >= DIGITS_LIMIT) {
                return bot.answerInlineQuery(
                    query.id,
                    []
                ).catch(logger);
            }

            let offer = {
                from   : query.from.username,
                amount : Number(match[1])
            };

            answer = {
                type  : 'article',
                id    : articleID(),
                title : debtTitle(offer.amount),
                input_message_content : {
                    message_text : userText(match[2], offer.amount)
                                || debtText(offer.amount, offer.from)
                },
                reply_markup : {
                    inline_keyboard : [[
                        {
                            text : '–û–∫ üåù',
                            callback_data : cipher.encode(offer, true)
                        },
                        {
                            text : '–ù–µ üåö',
                            callback_data : cipher.encode(offer, false)
                        }
                    ]]
                }
            };
        } else if (query.query == 'share' || query.query == '') {
            answer = {
                type  : 'article',
                id    : articleID(),
                title : '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è ü§ñ',
                input_message_content : {
                    message_text : shareText()
                }
            };
        } else {
            return bot.answerInlineQuery(
                query.id,
                []
            ).catch(logger);
        }

        return bot.answerInlineQuery(
            query.id,
            [answer],
            { cache_time : 0 }
        ).catch(logger);
    });

    let article_id = 0;
    function articleID() {
        return article_id++;
    };

    bot.on('callback_query', query => {
        if (query.data == 'update') {
            let stats;
            dataBase.getStats(query.from.username)
                .then(table => {
                    stats = table;
                    return bot.deleteMessage(
                        query.message.chat.id,
                        query.message.message_id
                    );
                })
                .then(() => {
                    return bot.answerCallbackQuery(
                        query.id,
                        { text : '–û–±–Ω–æ–≤–ª–µ–Ω–æ.' }
                    );
                })
                .then(() => {
                    return bot.sendMessage(
                        query.message.chat.id,
                        formatTable(stats),
                        { reply_markup : statsKeyboard }
                    );
                })
                .catch(logger);
        } else {
            let offer = cipher.decode(query.data);
            offer.to  = query.from.username;

            if (offer.to == offer.from) {
                if (offer.accept) {
                    bot.answerCallbackQuery(
                        query.id,
                        { text : `–ù–µ–ª—å–∑—è –¥–æ–ª–∂–∞—Ç—å —Å–µ–±–µ` }
                    ).catch(logger);
                } else {
                    bot.editMessageText(
                        `–û—Ç–º–µ–Ω–µ–Ω–æ @${offer.from}`,
                        { inline_message_id :
                            query.inline_message_id }
                    ).catch(logger);
                }
            } else {
                bot.editMessageText(
                        closedDealMsg(offer),
                        { inline_message_id :
                            query.inline_message_id }
                    )
                    .then(() => {
                        if (offer.accept)
                            return dataBase.saveDebt(offer);
                        else
                            return pass();
                    })
                    .catch(logger);
            }
        }
    });
};

const shareKeyboard = {
    reply_markup : JSON.stringify({
        inline_keyboard : [[ {
            text : '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è ü§ñ',
            switch_inline_query : ''
        } ]]
    })
};

function lineReducer(table, seed) {
    console.log(table, seed);
    if (!table.length)
        return '';
    return table.reduce((res, line) => {
        return res
             + `\n@${line.to_name}: ${line.amount}`;
    }, seed);
};

function lineAbs(line) {
    return {
        to_name : line.to_name,
        amount  : Math.abs(line.amount)
    };
};

function formatTable(table) {
    if (!table.length)
        return '';

    let debts = table.filter(debt => debt.amount > 0);
    let owes  = table.filter(debt => debt.amount < 0)
                     .map(lineAbs);

    return ''
    + lineReducer(debts, '–í—ã –¥–æ–ª–∂–Ω—ã:\n')
    + (debt.length && owes.length ? '\n\n' : '')
    + lineReducer(owes, '–í–∞–º –¥–æ–ª–∂–Ω—ã:\n');
};

const statsKeyboard = JSON.stringify({
    inline_keyboard : [[ {
        text : '–û–±–Ω–æ–≤–∏—Ç—å üîÑ',
        callback_data : 'update'
    } ]]
});

const debtRegexp = /(-?\d+)(.+)?/;

const DIGITS_LIMIT = 9;

function userText(text, amount) {
    if (text && (text.length > 1))
        return text.substr(1)
             + `\n\n`
             + `‚ÄºÔ∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${amount} ‚ÄºÔ∏è`;
}

function debtText(amount, to) {
    return `–Ø ${amount > 0 ? '—Ö–æ—á—É' : '–¥–∞—é'} ${Math.abs(amount)} (${to})`;
}

function offerButton(minus) {
    return (minus == '-' ? '–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å' : '–ü–æ–ø—Ä–æ—Å–∏—Ç—å') + ' üí∞';
}

function debtTitle(amount) {
    return `${amount > 0 ? `–ü–æ–ø—Ä–æ—Å–∏—Ç—å` : `–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å`} ${Math.abs(amount)}`;
}

function closedDealMsg(from, amount, to, accept) {
    let arg1 = amount > 0 ? `–¥–æ–ª–≥–∞ (–∫–æ–ª-–≤–æ: ${amount})` : -amount;
    let arg2 = accept ? `–ø—Ä–∏–Ω—è—Ç–æ` : `–æ—Ç–≤–µ—Ä–≥–Ω—É—Ç–æ`;
    return `–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ ${arg1} –±—ã–ª–æ ${arg2} @${to}. (${from})`
};

const states = {
    MAIN : 0
};

function pass() {
    return new Promise(next => next(...arguments));
};

function logger(error) {
    console.log('\n', error);
};

if (module) module.exports = Bot;
